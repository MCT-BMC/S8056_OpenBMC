From b12fb28b9e8baace7a64f2f1763333c83b4ec052 Mon Sep 17 00:00:00 2001
From: John Chung <john.chung@mic.com.tw>
Date: Mon, 17 Oct 2022 12:18:35 +0800
Subject: [PATCH] Support GPIO initialization feature with selected event

---
 gpioMon.cpp     | 46 ++++++++++++++++++++++++++++++++++++++++++++++
 gpioMon.hpp     | 15 +++++++++++++--
 gpioMonMain.cpp |  9 ++++++++-
 3 files changed, 67 insertions(+), 3 deletions(-)

diff --git a/gpioMon.cpp b/gpioMon.cpp
index 9c1fa29..c00d39d 100644
--- a/gpioMon.cpp
+++ b/gpioMon.cpp
@@ -103,6 +103,43 @@ void GpioMonitor::gpioEventHandler()
     scheduleEventHandler();
 }
 
+void GpioMonitor::initializationGPIO(int value)
+{
+    std::vector<std::string> targetsToStart;
+    if(gpioConfig.request_type == GPIOD_LINE_REQUEST_EVENT_FALLING_EDGE && !value)
+    {
+        targetsToStart = target["RISING"];
+    }
+    else if(gpioConfig.request_type == GPIOD_LINE_REQUEST_EVENT_RISING_EDGE && value)
+    {
+        targetsToStart = target["FALLING"];
+    }
+    else if(gpioConfig.request_type == GPIOD_LINE_REQUEST_EVENT_BOTH_EDGES)
+    {
+        if(value)
+        {
+            targetsToStart = target["RISING"];
+        }
+        else
+        {
+            targetsToStart = target["FALLING"];
+        }
+    }
+
+    if (!targetsToStart.empty())
+    {
+        auto bus = sdbusplus::bus::new_default();
+        for (auto &tar : targetsToStart)
+        {
+            auto method = bus.new_method_call(SYSTEMD_SERVICE, SYSTEMD_ROOT,
+                                              SYSTEMD_INTERFACE, "RestartUnit");
+            method.append(tar);
+            method.append("replace");
+            bus.call_noreply(method);
+        }
+    }
+}
+
 int GpioMonitor::requestGPIOEvents()
 {
 
@@ -122,6 +159,15 @@ int GpioMonitor::requestGPIOEvents()
         return -1;
     }
 
+    if(initialize)
+    {
+        std::string logInitMsg = gpioLineMsg + " initializing started";
+        log<level::INFO>(logInitMsg.c_str());
+
+        /* Initialize GPIO with event*/
+        initializationGPIO(gpiod_line_get_value(gpioLine));
+    }
+
     std::string logMsg = gpioLineMsg + " monitoring started";
     log<level::INFO>(logMsg.c_str());
 
diff --git a/gpioMon.hpp b/gpioMon.hpp
index 8c29741..b5ce166 100644
--- a/gpioMon.hpp
+++ b/gpioMon.hpp
@@ -39,10 +39,12 @@ class GpioMonitor
     GpioMonitor(gpiod_line* line, gpiod_line_request_config& config,
                 boost::asio::io_service& io, 
                 std::map<std::string, std::vector<std::string>> target,
-                const std::string& lineMsg, bool continueRun) :
+                const std::string& lineMsg, bool continueRun,
+                bool initialize) :
         gpioLine(line),
         gpioConfig(config), gpioEventDescriptor(io), target(target),
-        gpioLineMsg(lineMsg), continueAfterEvent(continueRun)
+        gpioLineMsg(lineMsg), continueAfterEvent(continueRun),
+        initialize(initialize)
     {
         requestGPIOEvents();
     };
@@ -66,6 +68,9 @@ class GpioMonitor
     /** @brief If the monitor should continue after event */
     bool continueAfterEvent;
 
+    /** @brief If the initialization should start before event */
+    bool initialize;
+
     /** @brief register handler for gpio event
      *
      *  @return  - 0 on success and -1 otherwise
@@ -77,6 +82,12 @@ class GpioMonitor
 
     /** @brief Handle the GPIO event and starts configured target */
     void gpioEventHandler();
+
+    /** @brief Initialization GPIO with selected event.
+     *
+     *  @param[in] value - GPIO line voltage level
+     */
+    void initializationGPIO(int value);
 };
 
 } // namespace gpio
diff --git a/gpioMonMain.cpp b/gpioMonMain.cpp
index 5eb7e94..75f0d6d 100644
--- a/gpioMonMain.cpp
+++ b/gpioMonMain.cpp
@@ -100,6 +100,8 @@ int main(int argc, char** argv)
 
         /* flag to monitor */
         bool flag = false;
+        /* flag to initial */
+        bool initialize = false;
 
         /* target to start */
         std::map<std::string, std::vector<std::string>> target;
@@ -174,9 +176,14 @@ int main(int argc, char** argv)
                 obj.at("Target").get_to(target);
         }
 
+        if (obj.find("initialization") != obj.end())
+        {
+            initialize = obj["initialization"];
+        }
+
         /* Create a monitor object and let it do all the rest */
         gpios.push_back(std::make_unique<phosphor::gpio::GpioMonitor>(
-            line, config, io, target, lineMsg, flag));
+            line, config, io, target, lineMsg, flag, initialize));
     }
     io.run();
 
-- 
2.25.1

