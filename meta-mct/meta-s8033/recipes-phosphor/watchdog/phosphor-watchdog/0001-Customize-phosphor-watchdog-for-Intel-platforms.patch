From e722faa85022225050866e5777213cf3dbf90a40 Mon Sep 17 00:00:00 2001
From: Osmond Chen <osmond.chen@mic.com.tw>
Date: Mon, 14 Mar 2022 16:45:53 +0800
Subject: [PATCH] Customize-phosphor-watchdog-for-Intel-platforms

---
 src/watchdog.cpp | 214 +++++++++++++++++++++++++++++++++++++++++++++++++++++--
 src/watchdog.hpp |  24 ++++++-
 2 files changed, 232 insertions(+), 6 deletions(-)
 mode change 100644 => 100755 src/watchdog.cpp
 mode change 100644 => 100755 src/watchdog.hpp

diff --git a/src/watchdog.cpp b/src/watchdog.cpp
old mode 100644
new mode 100755
index 05a95e9..23d848f
--- a/src/watchdog.cpp
+++ b/src/watchdog.cpp
@@ -1,5 +1,7 @@
 #include "watchdog.hpp"
 
+#include <systemd/sd-journal.h>
+
 #include <algorithm>
 #include <chrono>
 #include <phosphor-logging/elog.hpp>
@@ -7,6 +9,7 @@
 #include <sdbusplus/exception.hpp>
 #include <string_view>
 #include <xyz/openbmc_project/Common/error.hpp>
+#include <xyz/openbmc_project/State/Host/server.hpp>
 
 namespace phosphor
 {
@@ -19,9 +22,80 @@ using namespace phosphor::logging;
 using sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure;
 
 // systemd service to kick start a target.
-constexpr auto SYSTEMD_SERVICE = "org.freedesktop.systemd1";
+/*constexpr auto SYSTEMD_SERVICE = "org.freedesktop.systemd1";
 constexpr auto SYSTEMD_ROOT = "/org/freedesktop/systemd1";
-constexpr auto SYSTEMD_INTERFACE = "org.freedesktop.systemd1.Manager";
+constexpr auto SYSTEMD_INTERFACE = "org.freedesktop.systemd1.Manager";*/
+const static constexpr char* currentHostState = "CurrentHostState";
+const static constexpr char* hostStatusOff =
+    "xyz.openbmc_project.State.Host.HostState.Off";
+
+const static constexpr char* actionDescription = " due to Watchdog timeout";
+const static constexpr char* hardResetDescription = "Hard Reset - System reset";
+const static constexpr char* powerOffDescription =
+    "Power Down - System power down";
+const static constexpr char* powerCycleDescription =
+    "Power Cycle - System power cycle";
+const static constexpr char* timerExpiredDescription = "Timer expired";
+
+const static constexpr char* preInterruptActionNone =
+    "xyz.openbmc_project.State.Watchdog.PreTimeoutInterruptAction.None";
+
+const static constexpr char* preInterruptDescriptionSMI = "SMI";
+const static constexpr char* preInterruptDescriptionNMI = "NMI";
+const static constexpr char* preInterruptDescriptionMI = "Messaging Interrupt";
+
+const static constexpr char* reservedDescription = "Reserved";
+
+const static constexpr char* timerUseDescriptionBIOSFRB2 = "BIOS FRB2";
+const static constexpr char* timerUseDescriptionBIOSPOST = "BIOS/POST";
+const static constexpr char* timerUseDescriptionOSLoad = "OSLoad";
+const static constexpr char* timerUseDescriptionSMSOS = "SMS/OS";
+const static constexpr char* timerUseDescriptionOEM = "OEM";
+
+namespace restart
+{
+static constexpr const char* busName =
+    "xyz.openbmc_project.Control.Host.RestartCause";
+static constexpr const char* path =
+    "/xyz/openbmc_project/control/host0/restart_cause";
+static constexpr const char* interface =
+    "xyz.openbmc_project.Control.Host.RestartCause";
+static constexpr const char* property = "RequestedRestartCause";
+} // namespace restart
+
+// chassis state manager service
+namespace chassis
+{
+static constexpr const char* busName = "xyz.openbmc_project.State.Chassis";
+static constexpr const char* path = "/xyz/openbmc_project/state/chassis0";
+static constexpr const char* interface = "xyz.openbmc_project.State.Chassis";
+static constexpr const char* request = "RequestedPowerTransition";
+} // namespace chassis
+
+namespace host
+{
+static constexpr const char* busName = "xyz.openbmc_project.State.Host";
+static constexpr const char* path = "/xyz/openbmc_project/state/host0";
+static constexpr const char* interface = "xyz.openbmc_project.State.Host";
+static constexpr const char* request = "RequestedHostTransition";
+} // namespace host
+
+void Watchdog::powerStateChangedHandler(
+    const std::map<std::string, std::variant<std::string>>& props)
+{
+    const auto iter = props.find(currentHostState);
+    if (iter != props.end())
+    {
+        const std::string* powerState = std::get_if<std::string>(&iter->second);
+        if (powerState && (*powerState == hostStatusOff))
+        {
+            if (timerEnabled())
+            {
+                enabled(false);
+            }
+        }
+    }
+}
 
 void Watchdog::resetTimeRemaining(bool enableWatchdog)
 {
@@ -107,13 +181,103 @@ uint64_t Watchdog::interval(uint64_t value)
 // Optional callback function on timer expiration
 void Watchdog::timeOutHandler()
 {
+    PreTimeoutInterruptAction preTimeoutInterruptAction = preTimeoutInterrupt();
+    std::string preInterruptActionMessageArgs{};
+
     Action action = expireAction();
+    std::string actionMessageArgs{};
+
+    expiredTimerUse(currentTimerUse());
+
+    TimerUse timeUser = expiredTimerUse();
+    std::string timeUserMessage{};
+
     if (!this->enabled())
     {
         action = fallback->action;
     }
 
-    expiredTimerUse(currentTimerUse());
+    //expiredTimerUse(currentTimerUse());
+    switch (timeUser)
+    {
+        case Watchdog::TimerUse::BIOSFRB2:
+            timeUserMessage = timerUseDescriptionBIOSFRB2;
+            break;
+        case Watchdog::TimerUse::BIOSPOST:
+            timeUserMessage = timerUseDescriptionBIOSPOST;
+            break;
+        case Watchdog::TimerUse::OSLoad:
+            timeUserMessage = timerUseDescriptionOSLoad;
+            break;
+        case Watchdog::TimerUse::SMSOS:
+            timeUserMessage = timerUseDescriptionSMSOS;
+            break;
+        case Watchdog::TimerUse::OEM:
+            timeUserMessage = timerUseDescriptionOEM;
+            break;
+        default:
+            timeUserMessage = reservedDescription;
+            break;
+    }
+
+    switch (action)
+    {
+        case Watchdog::Action::HardReset:
+            actionMessageArgs = std::string(hardResetDescription) +
+                                std::string(actionDescription);
+            break;
+        case Watchdog::Action::PowerOff:
+            actionMessageArgs = std::string(powerOffDescription) +
+                                std::string(actionDescription);
+            break;
+        case Watchdog::Action::PowerCycle:
+            actionMessageArgs = std::string(powerCycleDescription) +
+                                std::string(actionDescription);
+            break;
+        case Watchdog::Action::None:
+            actionMessageArgs = timerExpiredDescription;
+            break;
+        default:
+            actionMessageArgs = reservedDescription;
+            break;
+    }
+
+    // Log into redfish event log
+    sd_journal_send("MESSAGE=IPMIWatchdog: Timed out ACTION=%s",
+                    convertForMessage(action).c_str(), "PRIORITY=%i", LOG_INFO,
+                    "REDFISH_MESSAGE_ID=%s", "OpenBMC.0.1.IPMIWatchdog",
+                    "REDFISH_MESSAGE_ARGS=%s. timer use: %s",
+                    actionMessageArgs.c_str(), timeUserMessage.c_str(), NULL);
+
+    switch (preTimeoutInterruptAction)
+    {
+        case Watchdog::PreTimeoutInterruptAction::SMI:
+            preInterruptActionMessageArgs = preInterruptDescriptionSMI;
+            break;
+        case Watchdog::PreTimeoutInterruptAction::NMI:
+            preInterruptActionMessageArgs = preInterruptDescriptionNMI;
+            break;
+        case Watchdog::PreTimeoutInterruptAction::MI:
+            preInterruptActionMessageArgs = preInterruptDescriptionMI;
+            break;
+        default:
+            preInterruptActionMessageArgs = reservedDescription;
+            break;
+    }
+
+    if (preInterruptActionNone != convertForMessage(preTimeoutInterruptAction))
+    {
+        preTimeoutInterruptOccurFlag(true);
+
+        sd_journal_send("MESSAGE=IPMIWatchdog: Pre Timed out Interrupt=%s",
+                        convertForMessage(preTimeoutInterruptAction).c_str(),
+                        "PRIORITY=%i", LOG_INFO, "REDFISH_MESSAGE_ID=%s",
+                        "OpenBMC.0.1.IPMIWatchdog",
+                        "REDFISH_MESSAGE_ARGS=Timer interrupt - %s due to "
+                        "Watchdog timeout. timer use: %s",
+                        preInterruptActionMessageArgs.c_str(),
+                        timeUserMessage.c_str(), NULL);
+    }
 
     auto target = actionTargetMap.find(action);
     if (target == actionTargetMap.end())
@@ -146,10 +310,27 @@ void Watchdog::timeOutHandler()
 
         try
         {
-            auto method = bus.new_method_call(SYSTEMD_SERVICE, SYSTEMD_ROOT,
+            /*auto method = bus.new_method_call(SYSTEMD_SERVICE, SYSTEMD_ROOT,
                                               SYSTEMD_INTERFACE, "StartUnit");
             method.append(target->second);
-            method.append("replace");
+            method.append("replace");*/
+            sdbusplus::message::message method;
+            if (action == Watchdog::Action::HardReset)
+            {
+                method = bus.new_method_call(host::busName, host::path,
+                                             "org.freedesktop.DBus.Properties",
+                                             "Set");
+                method.append(host::interface, host::request,
+                              std::variant<std::string>(target->second));
+            }
+            else
+            {
+                method = bus.new_method_call(chassis::busName, chassis::path,
+                                             "org.freedesktop.DBus.Properties",
+                                             "Set");
+                method.append(chassis::interface, chassis::request,
+                              std::variant<std::string>(target->second));
+            }
 
             bus.call_noreply(method);
         }
@@ -160,6 +341,29 @@ void Watchdog::timeOutHandler()
                             entry("ERROR=%s", e.what()));
             commit<InternalFailure>();
         }
+
+        // set restart cause for watchdog HardReset & PowerCycle actions
+        if ((action == Watchdog::Action::HardReset) ||
+            (action == Watchdog::Action::PowerCycle))
+        {
+            try
+            {
+                auto method = bus.new_method_call(
+                    restart::busName, restart::path,
+                    "org.freedesktop.DBus.Properties", "Set");
+                method.append(
+                    restart::interface, restart::property,
+                    std::variant<std::string>("xyz.openbmc_project.State.Host."
+                                              "RestartCause.WatchdogTimer"));
+                bus.call(method);
+            }
+            catch (sdbusplus::exception_t& e)
+            {
+                log<level::ERR>("Failed to set HostRestartCause property",
+                                entry("ERROR=%s", e.what()));
+                commit<InternalFailure>();
+            }
+        }
     }
 
     tryFallbackOrDisable();
diff --git a/src/watchdog.hpp b/src/watchdog.hpp
old mode 100644
new mode 100755
index 31cde63..3b79c8e
--- a/src/watchdog.hpp
+++ b/src/watchdog.hpp
@@ -73,7 +73,19 @@ class Watchdog : public WatchdogInherits
         bus(bus), actionTargetMap(std::move(actionTargetMap)),
         fallback(fallback), minInterval(minInterval),
         timer(event, std::bind(&Watchdog::timeOutHandler, this)),
-        objPath(objPath)
+        objPath(objPath),
+        powerStateChangedSignal(
+            bus,
+            sdbusplus::bus::match::rules::propertiesChanged(
+                "/xyz/openbmc_project/state/host0",
+                "xyz.openbmc_project.State.Host"),
+            [this](sdbusplus::message::message& msg) {
+                std::string objectName;
+                std::map<std::string, std::variant<std::string>> props;
+                msg.read(objectName, props);
+                powerStateChangedHandler(props);
+            })
+
     {
         // Use default if passed in otherwise just use default that comes
         // with object
@@ -90,6 +102,12 @@ class Watchdog : public WatchdogInherits
         tryFallbackOrDisable();
     }
 
+    /** @brief Disable watchdog when power status change meet
+     *         the specific requirement
+     */
+    void powerStateChangedHandler(
+        const std::map<std::string, std::variant<std::string>>& props);
+
     /** @brief Resets the TimeRemaining to the configured Interval
      *         Optionally enables the watchdog.
      *
@@ -178,6 +196,10 @@ class Watchdog : public WatchdogInherits
     /** @brief Contained timer object */
     sdeventplus::utility::Timer<sdeventplus::ClockId::Monotonic> timer;
 
+    /** @brief Optional Callback handler when power status change meet
+     * the specific requirement */
+    sdbusplus::bus::match_t powerStateChangedSignal;
+
     /** @brief Optional Callback handler on timer expirartion */
     void timeOutHandler();
 
-- 
2.7.4

