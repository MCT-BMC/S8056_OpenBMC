From beb4bd0b3add4a002ed8003f69dc02baefd83e8e Mon Sep 17 00:00:00 2001
From: John Chung <john.chung@mic.com.tw>
Date: Wed, 16 Mar 2022 11:08:27 +0800
Subject: [PATCH 09/11] Support setting fan contol mode in manager BMC OEM node

---
 redfish-core/lib/managers.hpp | 158 ++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 152 insertions(+), 6 deletions(-)

diff --git a/redfish-core/lib/managers.hpp b/redfish-core/lib/managers.hpp
index ef60dce..e7445d1 100755
--- a/redfish-core/lib/managers.hpp
+++ b/redfish-core/lib/managers.hpp
@@ -254,16 +254,19 @@ static constexpr const char* stepwiseConfigurationIface =
     "xyz.openbmc_project.Configuration.Stepwise";
 static constexpr const char* thermalModeIface =
     "xyz.openbmc_project.Control.ThermalMode";
+static constexpr const char* manualModeIface =
+    "xyz.openbmc_project.Control.Mode";
 
 inline void
     asyncPopulatePid(const std::string& connection, const std::string& path,
                      const std::string& currentProfile,
                      const std::vector<std::string>& supportedProfiles,
+                     const std::string& manualProfile,
                      const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
 {
 
     crow::connections::systemBus->async_method_call(
-        [asyncResp, currentProfile, supportedProfiles](
+        [asyncResp, currentProfile, supportedProfiles, manualProfile](
             const boost::system::error_code ec,
             const dbus::utility::ManagedObjectType& managedObj) {
             if (ec)
@@ -305,6 +308,11 @@ inline void
             }
             BMCWEB_LOG_ERROR << "profile = " << currentProfile << " !";
 
+            if (!manualProfile.empty())
+            {
+                configRoot["ManualMode"] = manualProfile;
+            }
+
             for (const auto& pathPair : managedObj)
             {
                 for (const auto& intfPair : pathPair.second)
@@ -1185,9 +1193,9 @@ struct GetPIDValues : std::enable_shared_from_this<GetPIDValues>
             "xyz.openbmc_project.ObjectMapper",
             "/xyz/openbmc_project/object_mapper",
             "xyz.openbmc_project.ObjectMapper", "GetSubTree", "/", 0,
-            std::array<const char*, 4>{
+            std::array<const char*, 5>{
                 pidConfigurationIface, pidZoneConfigurationIface,
-                objectManagerIface, stepwiseConfigurationIface});
+                objectManagerIface, stepwiseConfigurationIface, manualModeIface});
 
         // at the same time get the selected profile
         crow::connections::systemBus->async_method_call(
@@ -1272,6 +1280,80 @@ struct GetPIDValues : std::enable_shared_from_this<GetPIDValues>
             "/xyz/openbmc_project/object_mapper",
             "xyz.openbmc_project.ObjectMapper", "GetSubTree", "/", 0,
             std::array<const char*, 1>{thermalModeIface});
+
+        crow::connections::systemBus->async_method_call(
+            [self](const boost::system::error_code ec,
+                   const crow::openbmc_mapper::GetSubTreeType& subtreeLocal) {
+                if (ec || subtreeLocal.empty())
+                {
+                    return;
+                }
+                if (subtreeLocal[0].second.size() != 1)
+                {
+                    // invalid mapper response, should never happen
+                    BMCWEB_LOG_ERROR << "GetPIDValues: Mapper Error";
+                    messages::internalError(self->asyncResp->res);
+                    return;
+                }
+
+                self->manualStatus = true;
+
+                for(unsigned int i=0; i < subtreeLocal.size(); i++)
+                {
+                    const std::string& path = subtreeLocal[i].first;
+                    const std::string& owner = subtreeLocal[i].second[0].first;
+
+                    crow::connections::systemBus->async_method_call(
+                        [path, owner, self](
+                            const boost::system::error_code ec2,
+                            const boost::container::flat_map<
+                                std::string, std::variant<bool>>& resp) {
+                            if (ec2)
+                            {
+                                BMCWEB_LOG_ERROR << "GetPIDValues: Can't get "
+                                                    "manualModeIface "
+                                                << path;
+                                messages::internalError(self->asyncResp->res);
+                                return;
+                            }
+                            const bool* manual = nullptr;
+                            for (auto& [key, value] : resp)
+                            {
+                                if (key == "Manual")
+                                {
+                                    manual = std::get_if<bool>(&value);
+
+                                    if (manual == nullptr)
+                                    {
+                                        BMCWEB_LOG_ERROR
+                                            << "GetPIDValues: manual mode "
+                                            "iface invalid "
+                                            << path;
+                                        messages::internalError(
+                                            self->asyncResp->res);
+                                        return;
+                                    }
+                                }
+                            }
+                            if (manual == nullptr)
+                            {
+                                BMCWEB_LOG_ERROR << "GetPIDValues: manual mode "
+                                                    "iface invalid "
+                                                << path;
+                                messages::internalError(self->asyncResp->res);
+                                return;
+                            }
+                            self->manualStatus = self->manualStatus && *manual;
+                            self->manualProfile = self->manualStatus ? "true" : "false";
+                        },
+                        owner, path, "org.freedesktop.DBus.Properties", "GetAll",
+                        manualModeIface);
+                }
+            },
+            "xyz.openbmc_project.ObjectMapper",
+            "/xyz/openbmc_project/object_mapper",
+            "xyz.openbmc_project.ObjectMapper", "GetSubTree", "/", 0,
+            std::array<const char*, 1>{manualModeIface});
     }
 
     ~GetPIDValues()
@@ -1303,7 +1385,8 @@ struct GetPIDValues : std::enable_shared_from_this<GetPIDValues>
                     // should have found the objMgr by now
                     if (interface == pidConfigurationIface ||
                         interface == pidZoneConfigurationIface ||
-                        interface == stepwiseConfigurationIface)
+                        interface == stepwiseConfigurationIface ||
+                        interface == manualModeIface)
                     {
                         auto findObjMgr =
                             objectMgrPaths.find(connectionGroup.first);
@@ -1317,7 +1400,7 @@ struct GetPIDValues : std::enable_shared_from_this<GetPIDValues>
                         calledConnections.insert(connectionGroup.first);
 
                         asyncPopulatePid(findObjMgr->first, findObjMgr->second,
-                                         currentProfile, supportedProfiles,
+                                         currentProfile, supportedProfiles, manualProfile,
                                          asyncResp);
                         break;
                     }
@@ -1333,6 +1416,8 @@ struct GetPIDValues : std::enable_shared_from_this<GetPIDValues>
 
     std::vector<std::string> supportedProfiles;
     std::string currentProfile;
+    std::string manualProfile;
+    bool manualStatus;
     crow::openbmc_mapper::GetSubTreeType subtree;
     std::shared_ptr<bmcweb::AsyncResp> asyncResp;
 };
@@ -1353,7 +1438,8 @@ struct SetPIDValues : std::enable_shared_from_this<SetPIDValues>
         if (!redfish::json_util::readJson(
                 data, asyncResp->res, "PidControllers", pidControllers,
                 "FanControllers", fanControllers, "FanZones", fanZones,
-                "StepwiseControllers", stepwiseControllers, "Profile", profile))
+                "StepwiseControllers", stepwiseControllers, "Profile", profile,
+                "ManualMode", manual))
         {
             BMCWEB_LOG_ERROR
                 << "Illegal Property "
@@ -1530,6 +1616,64 @@ struct SetPIDValues : std::enable_shared_from_this<SetPIDValues>
                 "Current", dbus::utility::DbusVariantType(*profile));
         }
 
+        if (manual)
+        {
+            bool setManual = false;
+
+            if(*manual == "true")
+            {
+                setManual = true;
+            }
+            else if(*manual == "false")
+            {
+                setManual = false;
+            }
+            else
+            {
+                messages::actionParameterUnknown(response->res, "ManualMode",
+                                                 *manual);
+                return;
+            }
+
+            crow::connections::systemBus->async_method_call(
+                [setManual, response](const boost::system::error_code ec,
+                    const crow::openbmc_mapper::GetSubTreeType& subtreeLocal) {
+                    if (ec || subtreeLocal.empty())
+                    {
+                        return;
+                    }
+                    if (subtreeLocal[0].second.size() != 1)
+                    {
+                        // invalid mapper response, should never happen
+                        BMCWEB_LOG_ERROR << "SetPIDValues: Mapper Error";
+                        messages::internalError(response->res);
+                        return;
+                    }
+
+                    for(unsigned int i=0; i < subtreeLocal.size(); i++)
+                    {
+                        const std::string& path = subtreeLocal[i].first;
+                        const std::string& owner = subtreeLocal[i].second[0].first;
+
+                        crow::connections::systemBus->async_method_call(
+                            [response](const boost::system::error_code ec) {
+                                if (ec)
+                                {
+                                    BMCWEB_LOG_ERROR << "Error patching profile" << ec;
+                                    messages::internalError(response->res);
+                                }
+                            },
+                            owner, path,
+                            "org.freedesktop.DBus.Properties", "Set", manualModeIface,
+                            "Manual", std::variant<bool>(setManual));
+                    }
+                },
+                "xyz.openbmc_project.ObjectMapper",
+                "/xyz/openbmc_project/object_mapper",
+                "xyz.openbmc_project.ObjectMapper", "GetSubTree", "/", 0,
+                std::array<const char*, 1>{manualModeIface});
+        }
+
         for (auto& containerPair : configuration)
         {
             auto& container = containerPair.second;
@@ -1723,11 +1867,13 @@ struct SetPIDValues : std::enable_shared_from_this<SetPIDValues>
     std::vector<std::pair<std::string, std::optional<nlohmann::json>>>
         configuration;
     std::optional<std::string> profile;
+    std::optional<std::string> manual;
     dbus::utility::ManagedObjectType managedObj;
     std::vector<std::string> supportedProfiles;
     std::string currentProfile;
     std::string profileConnection;
     std::string profilePath;
+    bool manualStatus;
     size_t objectCount = 0;
 };
 
-- 
2.7.4

