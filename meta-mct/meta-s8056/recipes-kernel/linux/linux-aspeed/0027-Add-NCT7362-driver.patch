From 46b01c2433276ddb218c150ab9808caa6f230f51 Mon Sep 17 00:00:00 2001
From: "jocelyn.chou" <jocelyn.chou@mic.com.tw>
Date: Wed, 26 Oct 2022 08:52:15 +0800
Subject: [PATCH] [s8056] Add NCT7362 driver.

---
 drivers/hwmon/Kconfig   |  10 +
 drivers/hwmon/Makefile  |   1 +
 drivers/hwmon/nct7362.c | 640 ++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 651 insertions(+)
 create mode 100644 drivers/hwmon/nct7362.c

diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 93fa206..736e4c4 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -1467,6 +1467,16 @@ config SENSORS_NCT7904
 	  This driver can also be built as a module. If so, the module
 	  will be called nct7904.
 
+config SENSORS_NCT7362
+	tristate "Nuvoton NCT7362Y"
+	depends on I2C
+	help
+	  If you say yes here you get support for the Nuvoton NCT7362Y
+	  hardware monitoring chip.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called nct7362.
+
 config SENSORS_NPCM7XX
 	tristate "Nuvoton NPCM750 and compatible PWM and Fan controllers"
 	imply THERMAL
diff --git a/drivers/hwmon/Makefile b/drivers/hwmon/Makefile
index 160ffa0..391f5c6 100644
--- a/drivers/hwmon/Makefile
+++ b/drivers/hwmon/Makefile
@@ -152,6 +152,7 @@ obj-$(CONFIG_SENSORS_NCT6683)	+= nct6683.o
 obj-$(CONFIG_SENSORS_NCT6775)	+= nct6775.o
 obj-$(CONFIG_SENSORS_NCT7802)	+= nct7802.o
 obj-$(CONFIG_SENSORS_NCT7904)	+= nct7904.o
+obj-$(CONFIG_SENSORS_NCT7362)	+= nct7362.o
 obj-$(CONFIG_SENSORS_NPCM7XX)	+= npcm750-pwm-fan.o
 obj-$(CONFIG_SENSORS_NSA320)	+= nsa320-hwmon.o
 obj-$(CONFIG_SENSORS_NTC_THERMISTOR)	+= ntc_thermistor.o
diff --git a/drivers/hwmon/nct7362.c b/drivers/hwmon/nct7362.c
new file mode 100644
index 0000000..b6eb7c6
--- /dev/null
+++ b/drivers/hwmon/nct7362.c
@@ -0,0 +1,640 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * nct7362.c - driver for Nuvoton NCT7362Y.
+ *
+ * Copyright (C) 2014  Guenter Roeck <linux@roeck-us.net>
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/hwmon.h>
+#include <linux/mutex.h>
+
+#define FANCTL_MAX        0x10 // Counted from 1
+#define INT_OUTPUT_CONFIG 0x1C
+#define INT_MISC_CONFIG   0x1D
+#define GPIO0_3_CONFIG    0x20
+#define GPIO4_7_CONFIG    0x21
+#define GPIO10_13_CONFIG  0x22
+#define GPIO14_17_CONFIG  0x23
+#define FAN0_7_FANIN_STS  0x32
+#define FAN8_15_FANIN_STS 0x33
+#define FAN0_7_FANIN_LOW_SPD  0x34
+#define FAN8_15_FANIN_LOW_SPD 0x35
+#define EN_PWM0_7        0x38
+#define EN_PWM8_15       0x39
+#define EN_FANIN_MONTOR  0x40
+#define EN_FANIN0_7      0x41
+#define EN_FANIN8_15     0x42
+#define FANIN_HV_REG     0x48 // x=0~15, reg = 48h + x*02h = 48h~66h
+#define FANIN_LV_REG     0x49 // x=0~15, reg = 49h + x*02h = 49h~67h
+#define FANIN_THR_HB     0x6C // x=0~15, reg = 6Ch + x*02h = 6Ch~8Ah
+#define FANIN_THR_LB     0x6D // x=0~15, reg = 6Dh + x*02h = 6Dh~8Bh
+#define FSCP_DUTY_REG    0x90 // x=0~15, reg = 90h + x*02h = 90h~AEh
+#define DRVNAME "nct7362"
+
+static const unsigned short normal_i2c[] = {
+	0x22, 0x23, I2C_CLIENT_END
+};
+
+struct nct7362_data {
+	struct i2c_client *client;
+	struct mutex access_lock; // for multi-byte read and write operations
+	u16 fanin_mask;           // finin monitor or not
+	u8 fan_mode[FANCTL_MAX];  // control by pwm or drive low
+        u8 fan_alarm[2];
+};
+
+static const char * const fanin_thr_names[] = {
+	"fanin0-threshold",
+	"fanin1-threshold",
+	"fanin2-threshold",
+	"fanin3-threshold",
+	"fanin4-threshold",
+	"fanin5-threshold",
+	"fanin6-threshold",
+	"fanin7-threshold",
+};
+
+/* Access functions */
+/* Read 1-byte register. Returns unsigned reg or -ERRNO on error. */
+static int nct7362_read_reg(struct nct7362_data *data, unsigned int reg)
+{
+	struct i2c_client *client = data->client;
+	int ret;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+
+	return ret;
+}
+
+/* Write 1-byte register. Returns 0 or -ERRNO on error. */
+static int nct7362_write_reg(struct nct7362_data *data, unsigned int reg, u8 val)
+{
+	struct i2c_client *client = data->client;
+	int ret;
+
+	ret = i2c_smbus_write_byte_data(client, reg, val);
+
+	return ret;
+}
+
+static int nct7362_read_fan(struct device *dev, u32 attr, int channel, long *val)
+{
+	struct nct7362_data *data = dev_get_drvdata(dev);
+        unsigned int fin_hv, fin_lv;
+        unsigned int cnt, rpm;
+        int ret;
+        int bit = channel;
+        int fan_set = 0;
+        switch (attr)
+        {
+        case hwmon_fan_input:
+
+                mutex_lock(&data->access_lock);
+
+                fin_hv = nct7362_read_reg(data, FANIN_HV_REG + channel * 2);
+                if (ret < 0)
+                {
+                        mutex_unlock(&data->access_lock);
+                        return ret;
+                }
+                fin_lv = nct7362_read_reg(data, FANIN_LV_REG + channel * 2);
+                if (ret < 0)
+                        return ret;
+
+                cnt = (fin_hv << 5) | (fin_lv & 0x1f);
+
+                if (cnt == 0 || cnt == 0x1fff)
+                        rpm = 0;
+                else
+                        rpm = 1350000 / cnt;
+                *val = rpm;
+
+                mutex_unlock(&data->access_lock);
+                return 0;
+
+        case hwmon_fan_min:
+
+                mutex_lock(&data->access_lock);
+
+                ret = nct7362_read_reg(data, FANIN_THR_HB + channel * 2);
+                if (ret < 0)
+                {
+                        mutex_unlock(&data->access_lock);
+                        return ret;
+                }
+
+                fin_hv = ret;
+                ret = nct7362_read_reg(data, FANIN_THR_LB + channel * 2);
+                if (ret < 0)
+                        return ret;
+                fin_lv = ret;
+
+                cnt = (fin_hv << 5) | (fin_lv & 0x1f);
+                if (cnt == 0 || cnt == 0x1fff || (fin_hv== 0xff && fin_lv == 0x1e))
+                        rpm = 0;
+                else
+                        rpm = 1350000 / cnt;
+                *val = rpm;
+
+                mutex_unlock(&data->access_lock);
+                return 0;
+
+        case hwmon_fan_alarm:
+
+                if (channel > 7)
+                {
+                        bit = channel - 8; // Fan(channel) 8~15 start from bit 0
+                        fan_set = 1;
+                }
+
+                ret = nct7362_read_reg(data, channel <= 7 ? FAN0_7_FANIN_STS : FAN8_15_FANIN_STS);
+
+		if (ret < 0)
+			return ret;
+
+		if (!data->fan_alarm[fan_set])
+                {
+			data->fan_alarm[fan_set] = ret & 0xff;
+                }
+		else // If there is new alarm showing up
+                {
+			data->fan_alarm[fan_set] |= (ret & 0xff);
+                }
+		*val = ret & BIT(bit) ? 1 : 0;
+
+		if (*val) // Needs to clean the alarm if alarm existing
+                {
+			data->fan_alarm[fan_set] ^= 1 << bit;
+                }
+                return 0;
+
+        case hwmon_fan_min_alarm:
+
+                if (channel > 7)
+                {
+                        bit = channel - 8; // Fan(channel) 8~15 start from bit 0
+                }
+
+                ret = nct7362_read_reg(data, channel <= 7 ? FAN0_7_FANIN_LOW_SPD : FAN8_15_FANIN_LOW_SPD);
+
+		if (ret < 0)
+			return ret;
+
+		*val = ret & BIT(bit) ? 1 : 0;
+
+                return 0;
+	default:
+	        return -EOPNOTSUPP;
+	}
+}
+
+static umode_t nct7362_fan_is_visible(const void *_data, u32 attr, int channel)
+{
+	const struct nct7362_data *data = _data;
+
+	switch (attr) 
+	{
+	case hwmon_fan_input:
+	case hwmon_fan_alarm:
+        case hwmon_fan_min_alarm:
+                if (data->fanin_mask & (1 << channel))
+		        return 0444;
+		break;
+	case hwmon_fan_min:
+		if (data->fanin_mask & (1 << channel))
+			return 0644;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int nct7362_read_pwm(struct device *dev, u32 attr, int channel, long *val)
+{
+        struct nct7362_data *data = dev_get_drvdata(dev);
+        int ret;
+        int bit = channel;
+
+        switch (attr) 
+        {
+	 case hwmon_pwm_input:
+                ret = nct7362_read_reg(data, FSCP_DUTY_REG + channel * 2);
+                if (ret < 0)
+                        return ret;
+                *val = ret;
+             	break;
+
+	 case hwmon_pwm_enable:
+                if (channel > 7)
+                {
+                        bit = channel - 8; // PWM(channel) 8~15 start from bit 0
+                }
+
+                 ret = nct7362_read_reg(data, channel <= 7 ? EN_PWM0_7 : EN_PWM8_15);
+
+		if (ret < 0)
+			return ret;
+
+		*val = ret & BIT(bit) ? 2 : 1;
+		break;
+	default:
+                return -EOPNOTSUPP;
+        }
+
+        return 0;
+}
+
+static int nct7362_write_pwm(struct device *dev, u32 attr, int channel, long val)
+{
+        struct nct7362_data *data = dev_get_drvdata(dev);
+        int ret;
+        u8 bit = channel;
+
+        switch (attr)
+        {
+	 case hwmon_pwm_input:
+                    if (val < 0 || val > 255)
+                        return -EINVAL;
+                    ret = nct7362_write_reg(data, FSCP_DUTY_REG + channel * 2, val);
+                    break;
+
+	 case hwmon_pwm_enable:
+                mutex_lock(&data->access_lock);
+                if (val < 1 || val > 2 || (val == 2 && !data->fan_mode[channel]))
+		            return -EINVAL;
+
+                if (channel > 7)
+                {
+                        bit = channel - 8; // PWM(channel) 8~15 start from bit 0
+                }
+
+		ret = nct7362_read_reg(data, channel <= 7 ? EN_PWM0_7 : EN_PWM8_15);
+
+		ret = nct7362_write_reg(data, channel <= 7 ? EN_PWM0_7 : EN_PWM8_15,
+					val == 2 ? ret | BIT(bit) : ret & ~BIT(bit));
+
+                mutex_unlock(&data->access_lock);
+                break;
+	 default:
+                
+                return -EOPNOTSUPP;
+        }
+
+        return 0;
+}
+
+static int nct7362_write_fan(struct device *dev, u32 attr, int channel, long val)
+{
+        struct nct7362_data *data = dev_get_drvdata(dev);
+        int ret;
+        unsigned int fin_hv, fin_lv;
+
+        switch (attr)
+        {
+	 case hwmon_fan_min:
+                mutex_lock(&data->access_lock);
+	         if (val <= 0)
+                        val = 0x1fff;
+	         else
+                        val = clamp_val(DIV_ROUND_CLOSEST(1350000, val), 1, 0x1fff);
+
+	         fin_hv = (val >> 5) & 0xff;
+	         ret = nct7362_write_reg(data, FANIN_THR_HB + channel * 2, fin_hv);
+                if (ret < 0)
+	         {
+	                 mutex_unlock(&data->access_lock);
+			 return ret;
+	         }
+	         fin_lv = val & 0x1f;
+	         ret = nct7362_write_reg(data, FANIN_THR_LB + channel * 2, fin_lv);
+	         mutex_unlock(&data->access_lock);
+	         break;
+	 default:
+
+                return -EOPNOTSUPP;
+        }
+
+        return 0;
+}
+
+
+static umode_t nct7362_pwm_is_visible(const void *_data, u32 attr, int channel)
+{
+        switch (attr)
+        {
+	 case hwmon_pwm_input:
+	 case hwmon_pwm_enable:
+                return 0644;
+
+	 default:
+                return 0;
+        }
+}
+
+static int nct7362_read(struct device *dev, enum hwmon_sensor_types type,
+			u32 attr, int channel, long *val)
+{
+        switch (type)
+        {
+        case hwmon_fan:
+	        return nct7362_read_fan(dev, attr, channel, val);
+
+	 case hwmon_pwm:
+	        return nct7362_read_pwm(dev, attr, channel, val);
+
+	 default:
+	        return -EOPNOTSUPP;
+        }
+}
+
+static int nct7362_write(struct device *dev, enum hwmon_sensor_types type,
+			 u32 attr, int channel, long val)
+{
+	switch (type)
+	{
+	case hwmon_fan:
+	        return nct7362_write_fan(dev, attr, channel, val);
+
+	case hwmon_pwm:
+                return nct7362_write_pwm(dev, attr, channel, val);
+
+	default:
+                return -EOPNOTSUPP;
+	}
+}
+
+static umode_t nct7362_is_visible(const void *data,
+				  enum hwmon_sensor_types type,
+				  u32 attr, int channel)
+{
+        switch (type)
+        {
+	case hwmon_fan:
+                return nct7362_fan_is_visible(data, attr, channel);
+
+	case hwmon_pwm:
+                return nct7362_pwm_is_visible(data, attr, channel);
+
+	default:
+                return 0;
+        }
+}
+
+static const struct hwmon_channel_info *nct7362_info[] = {
+
+	HWMON_CHANNEL_INFO(fan,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM,
+			   HWMON_F_INPUT | HWMON_F_ENABLE | HWMON_F_MIN |
+                           HWMON_F_MIN_ALARM | HWMON_F_ALARM),
+	HWMON_CHANNEL_INFO(pwm,
+			   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,
+			   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,
+			   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,
+			   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,
+			   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,
+			   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,
+			   HWMON_PWM_INPUT | HWMON_PWM_ENABLE,
+			   HWMON_PWM_INPUT | HWMON_PWM_ENABLE),
+	NULL
+};
+
+
+static const struct hwmon_ops nct7362_hwmon_ops = {
+	.is_visible = nct7362_is_visible,
+	.read = nct7362_read,
+	.write = nct7362_write,
+};
+
+static const struct hwmon_chip_info nct7362_chip_info = {
+	.ops = &nct7362_hwmon_ops,
+	.info = nct7362_info,
+};
+
+static int nct7362_init_chip(struct nct7362_data *data, struct device_node *np)
+{
+	int ret;
+        int config;
+        u8 val;
+        int i;
+
+        mutex_lock(&data->access_lock);
+        ret = of_property_read_u32(np, "pin-func-config", &config);
+	if (ret >= 0)
+	{
+                val = (config & 0xff);
+                ret = nct7362_write_reg(data, GPIO0_3_CONFIG, val);
+                if (ret < 0)
+                        return ret;
+
+                val = ((config >> 8) & 0xff);
+                ret = nct7362_write_reg(data, GPIO4_7_CONFIG, val);
+                if (ret < 0)
+                        return ret;
+
+                val = ((config >> 16) & 0xff);
+                ret = nct7362_write_reg(data, GPIO10_13_CONFIG, val);
+                if (ret < 0)
+                        return ret;
+
+                val = ((config >> 24) & 0xff);
+                ret = nct7362_write_reg(data, GPIO14_17_CONFIG, val);
+                if (ret < 0)
+                        return ret;
+        }
+        else
+        {
+            printk( "%s has no valid pin-func-config property %d\n", np->full_name, ret);
+        }
+
+        ret = of_property_read_u32(np, "interrupt-config", &config);
+	if (ret >= 0)
+        {
+                val = (config & 0xff);
+                ret = nct7362_write_reg(data, INT_OUTPUT_CONFIG, val);
+                if (ret < 0)
+                        return ret;
+
+                val = ((config >> 8) & 0xff);
+                ret = nct7362_write_reg(data, INT_MISC_CONFIG, val);
+                if (ret < 0)
+                        return ret;
+        }
+        else
+        {
+                printk( "%s has no valid interrupt-config property %d\n", np->full_name, ret);
+        }
+
+        ret = of_property_read_u32(np, "pwm-enable", &config);
+	if (ret >= 0)
+        {
+                val = (config & 0xff);
+                ret = nct7362_write_reg(data, EN_PWM0_7, val);
+                if (ret < 0)
+                        return ret;
+
+                val = ((config >> 8) & 0xff);
+                ret = nct7362_write_reg(data, EN_PWM8_15, val);
+                if (ret < 0)
+                        return ret;
+        }
+        else
+        {
+                printk( "%s has no valid pwm-enable property %d\n", np->full_name, ret);
+        }
+
+        ret = of_property_read_u32(np, "fanin-enable", &config);
+	if (ret >= 0)
+        {
+                val = (config & 0xff);
+                ret = nct7362_write_reg(data, EN_FANIN_MONTOR, val);
+                if (ret < 0)
+                        return ret;
+
+                val = ((config >> 8) & 0xff);
+                ret = nct7362_write_reg(data, EN_FANIN0_7, val);
+                if (ret < 0)
+                        return ret;
+
+                val = ((config >> 16) & 0xff);
+                ret = nct7362_write_reg(data, EN_FANIN8_15, val);
+                if (ret < 0)
+                        return ret;
+        }
+        else
+        {
+                printk( "%s has no valid fanin-enable property %d\n", np->full_name, ret);
+        }
+
+        for (i=0 ; i<8 ; i++)
+        {
+                ret = of_property_read_u32(np, fanin_thr_names[i], &config);
+	        if (ret >= 0) 
+                {
+                    val = 0;
+                    val = (config & 0xff);
+                    ret = nct7362_write_reg(data, FANIN_THR_LB + i * 2, val);
+                    if (ret < 0)
+                            return ret;
+
+                    val = ((config >> 8) & 0xff);
+                    ret = nct7362_write_reg(data, FANIN_THR_HB + i * 2, val);
+                    if (ret < 0)
+                            return ret;
+                }
+                //else
+                //        printk( "%s has no valid %s property %d\n", np->full_name, fanin_thr_names[i], ret);
+
+        }
+        mutex_unlock(&data->access_lock);
+        return ret;
+}
+
+static int nct7362_probe(struct i2c_client *client)
+{
+        struct nct7362_data *data;
+        struct device *hwmon_dev;
+        struct device *dev = &client->dev;
+        struct device_node *np = client->dev.of_node;
+        int ret, bit, i;
+
+        data = devm_kzalloc(dev, sizeof(struct nct7362_data), GFP_KERNEL);
+        if (data == NULL)
+                return -ENOMEM;
+
+        data->client = client;
+
+        mutex_init(&data->access_lock);
+
+        ret = nct7362_init_chip(data, np);
+
+        // FANIN attributes
+        ret = nct7362_read_reg(data, EN_FANIN0_7);
+        if (ret < 0)
+                return ret;
+        data->fanin_mask = ret;
+
+        ret = nct7362_read_reg(data, EN_FANIN8_15);
+        if (ret < 0)
+                return ret;
+        data->fanin_mask = ((ret & 0xff) << 8) | data->fanin_mask;
+
+	for (i = 0; i < FANCTL_MAX; i++) {
+                if (i <= 7)
+                {
+                        ret = nct7362_read_reg(data, EN_PWM0_7);
+                        bit = i;
+                }
+                else
+                {
+                        ret = nct7362_read_reg(data, EN_PWM8_15);
+                        bit = i - 8;
+                }
+		if (ret < 0)
+			return ret;
+		data->fan_mode[i] = ret & BIT(bit) ? 1 : 0;
+	}
+
+        hwmon_dev = devm_hwmon_device_register_with_info(dev, client->name, 
+                                                         data,
+						         &nct7362_chip_info, NULL);
+
+        return PTR_ERR_OR_ZERO(hwmon_dev);
+}
+
+static const struct i2c_device_id nct7362_id[] = {
+	{"nct7362", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, nct7362_id);
+
+static struct i2c_driver nct7362_driver = {
+	.class = I2C_CLASS_HWMON,
+	.driver = {
+		.name = "nct7362",
+	},
+	.probe_new = nct7362_probe,
+	.id_table = nct7362_id,
+	.address_list = normal_i2c,
+};
+
+module_i2c_driver(nct7362_driver);
+
+MODULE_AUTHOR("Vadim V. Vlasov <vvlasov@dev.rtsoft.ru>");
+MODULE_DESCRIPTION("Hwmon driver for NUVOTON NCT7362");
+MODULE_LICENSE("GPL");
-- 
2.7.4

