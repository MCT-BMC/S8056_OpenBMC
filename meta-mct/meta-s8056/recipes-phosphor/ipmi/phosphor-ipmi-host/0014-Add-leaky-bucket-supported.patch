From df9546e2a260ef2bc280f0e0ac9318243a61817c Mon Sep 17 00:00:00 2001
From: John Chung <john.chung@mic.com.tw>
Date: Tue, 22 Mar 2022 14:52:17 +0800
Subject: [PATCH 14/24] Add leaky bucket supported

Set correct setting for SEL filter feature if statement
---
 dbus-sdr/storagecommands.cpp | 106 +++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 101 insertions(+), 5 deletions(-)

diff --git a/dbus-sdr/storagecommands.cpp b/dbus-sdr/storagecommands.cpp
index 07b0561..900e765 100755
--- a/dbus-sdr/storagecommands.cpp
+++ b/dbus-sdr/storagecommands.cpp
@@ -1317,15 +1317,109 @@ static constexpr char const* ipmiSELAddInterface = "xyz.openbmc_project.Logging.
 
 static const std::string ipmiSELAddMessage = "Add OEM SEL Entry";
 
+//MCT ecc filter
+static constexpr const char* sdrEventOnlyFile = "/usr/share/ipmi-providers/sdr_event_only.json";
+constexpr static const uint16_t biosId = 0x3f;
+constexpr static const uint8_t sensorTypeMemory = 0x0c;
+constexpr static const uint8_t eventDataMemCorrectableEcc = 0;
+
+boost::container::flat_map<uint8_t, std::string> eccMap;
+
+static void loadEccMap(void)
+{
+    static bool loaded = false;
+    uint16_t ownerId;
+    uint8_t sensorNum;
+    uint8_t sensorType;
+    std::string sensorName;
+
+    if(loaded)
+    {
+        return;
+    }
+    loaded = true;
+
+    eccMap.clear();
+    std::ifstream sdrStream(sdrEventOnlyFile);
+    if(!sdrStream.is_open())
+    {
+        std::cerr << "NO defined SDR found\n";
+    }
+    else
+    {
+        auto data = nlohmann::json::parse(sdrStream, nullptr, false);
+        if (data.is_discarded())
+        {
+            std::cerr << "syntax error in " << sdrEventOnlyFile << "\n";
+        }
+        else
+        {
+            int idx = 0;
+            while (!data[idx].is_null())
+            {
+                ownerId = std::stoul((std::string)data[idx]["ownerId"], nullptr, 16);
+                sensorNum = std::stoul((std::string)data[idx]["sensorNumber"], nullptr, 16);
+                sensorType = std::stoul((std::string)data[idx]["sensorType"], nullptr, 16);
+                sensorName = data[idx]["sensorName"];
+                if(biosId == ownerId && sensorTypeMemory == sensorType)
+                {
+
+                    eccMap[sensorNum] = sensorName;
+                }
+                idx++;
+            }
+        }
+        sdrStream.close();
+    }
+
+    for(auto const& pair:eccMap)
+    {
+        std::cerr << (unsigned)pair.first << ":" << pair.second << '\n';
+    }
+}
+
 ipmi::RspType<uint16_t> ipmiStorageAddSELEntry(
     uint16_t recordID, uint8_t recordType, uint32_t timestamp,
     uint16_t generatorID, uint8_t evmRev, uint8_t sensorType, uint8_t sensorNum,
     uint8_t eventType, uint8_t eventData1, uint8_t eventData2,
     uint8_t eventData3)
 {
-    // Per the IPMI spec, need to cancel any reservation when a SEL entry is
-    // added
-    cancelSELReservation();
+    loadEccMap();
+    std::shared_ptr<sdbusplus::asio::connection> bus = getSdBus();
+    uint16_t responseID = 0xFFFF;
+    bool overflow = false;
+
+    //ecc fliter
+    if( (biosId == generatorID) && (sensorType == sensorTypeMemory) &&
+        (eventType == 0x6f) && ((eventData1 & 0x0f) == eventDataMemCorrectableEcc))
+    {
+        auto ecc = eccMap.find(sensorNum);
+        //find ecc in sdr, call leaky bucket sensor
+        if (ecc != eccMap.end())
+        {
+            //std::cerr << (unsigned)ecc->first << ":" << ecc->second << '\n';
+            sdbusplus::message::message addEcc = bus->new_method_call(
+                "xyz.openbmc_project.leaklyBucket",
+                "/xyz/openbmc_project/leakyBucket/HOST_DIMM_ECC",
+                "xyz.openbmc_project.Sensor.Value",
+                "increaseEccToBucket");
+            addEcc.append(ecc->second, sensorNum);
+
+            try
+            {
+                auto ret = bus->call(addEcc);
+                ret.read(overflow);
+            }
+            catch (sdbusplus::exception_t& e)
+            {
+                std::cerr << "call increaseEccToBucket failed\n";
+            }
+            if(!overflow)
+            {
+                return ipmi::responseSuccess(responseID);
+            }
+        }
+    }
 
     //mitac start: add to sel
     std::vector<uint8_t> eventData(9, 0xFF);
@@ -1339,12 +1433,10 @@ ipmi::RspType<uint16_t> ipmiStorageAddSELEntry(
     eventData[7] = eventData2;
     eventData[8] = eventData3;
 
-    std::shared_ptr<sdbusplus::asio::connection> bus = getSdBus();
     sdbusplus::message::message writeSEL = bus->new_method_call(
         ipmiSELService, ipmiSELPath, ipmiSELAddInterface, "IpmiSelAddOem");
     writeSEL.append(ipmiSELAddMessage,  eventData, recordType);
 
-    uint16_t responseID = 0xFFFF;
     try
     {
         auto ret = bus->call(writeSEL);
@@ -1356,6 +1448,10 @@ ipmi::RspType<uint16_t> ipmiStorageAddSELEntry(
     }
     //mitac end
 
+    // Per the IPMI spec, need to cancel any reservation when a SEL entry is
+    // added
+    cancelSELReservation();
+
     return ipmi::responseSuccess(responseID);
 }
 
-- 
2.7.4

