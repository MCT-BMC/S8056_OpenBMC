From 0f8caeaee78f8d1ff769a61b28250f977cefd6c0 Mon Sep 17 00:00:00 2001
From: John Chung <john.chung@mic.com.tw>
Date: Wed, 16 Mar 2022 15:46:33 +0800
Subject: [PATCH 02/24] Modified IP related setting and fix some issue

Move unspecified ip source from static to DHCP.
Fix set static ip fail issue.
Add ARP control status supported.
Implement IPMI get/set IP family enable command
---
 transporthandler.cpp | 136 ++++++++++++++++++++++++++++++++++++++++++++++++---
 transporthandler.hpp |   1 +
 2 files changed, 129 insertions(+), 8 deletions(-)
 mode change 100644 => 100755 transporthandler.cpp
 mode change 100644 => 100755 transporthandler.hpp

diff --git a/transporthandler.cpp b/transporthandler.cpp
old mode 100644
new mode 100755
index f7585a4..df98d51
--- a/transporthandler.cpp
+++ b/transporthandler.cpp
@@ -170,6 +170,99 @@ EthernetInterface::DHCPConf getDHCPProperty(sdbusplus::bus::bus& bus,
     return EthernetInterface::convertDHCPConfFromString(dhcpstr);
 }
 
+void setDHCPProperty(sdbusplus::bus::bus& bus, const ChannelParams& params,
+                     const EthernetInterface::DHCPConf requestedDhcp)
+{
+    std::string newDhcp =
+        sdbusplus::xyz::openbmc_project::Network::server::convertForMessage(
+            requestedDhcp);
+    setDbusProperty(bus, params.service, params.logicalPath, INTF_ETHERNET,
+                    "DHCPEnabled", newDhcp);
+}
+
+std::string getInterfaceNameProperty(sdbusplus::bus::bus& bus,
+                                            const ChannelParams& params)
+{
+    std::string interfaceName = std::get<std::string>(getDbusProperty(
+        bus, params.service, params.logicalPath, INTF_ETHERNET, "InterfaceName"));
+    return interfaceName;
+}
+
+const static std::string dhcpConfigPath = "/etc/dhcp-config.json";
+
+bool saveChannelDhcpConfig(const uint8_t channel, uint8_t enables)
+{
+    std::string interfaceName =
+                channelCall<getInterfaceNameProperty>(channel);
+
+    std::ifstream dhcpConfig(dhcpConfigPath);
+    nlohmann::json dhcpConfigInfo;
+
+    if(dhcpConfig)
+    {
+        dhcpConfigInfo = nlohmann::json::parse(dhcpConfig, nullptr, false);
+    }
+
+    switch (static_cast<IPFamilyEnables>(enables))
+    {
+        case IPFamilyEnables::DualStack:
+            dhcpConfigInfo[interfaceName] = "DualStack";
+            break;
+        case IPFamilyEnables::IPv4Only:
+            dhcpConfigInfo[interfaceName] = "IPv4Only";
+            break;
+        case IPFamilyEnables::IPv6Only:
+            dhcpConfigInfo[interfaceName] = "IPv6Only";
+            break;
+    }
+
+    std::ofstream dhcpConfigOutput(dhcpConfigPath);
+    dhcpConfigOutput << dhcpConfigInfo << std::endl;
+    dhcpConfigOutput.close();
+
+    std::ofstream dhcpUpdateFlag ("/run/dhcp-update");
+    dhcpUpdateFlag << interfaceName
+                   << ","
+                   << dhcpConfigInfo[interfaceName]
+                   << std::endl;
+    dhcpUpdateFlag.close();
+
+    return true;
+}
+
+IPFamilyEnables getChannelDhcpConfig(const uint8_t channel)
+{
+    std::string interfaceName =
+                channelCall<getInterfaceNameProperty>(channel);
+
+    std::ifstream dhcpConfig(dhcpConfigPath);
+
+    nlohmann::json dhcpConfigInfo;
+    IPFamilyEnables channelIPFamily = IPFamilyEnables::DualStack;
+
+    if(!dhcpConfig)
+    {
+        return channelIPFamily;
+    }
+
+    dhcpConfigInfo = nlohmann::json::parse(dhcpConfig, nullptr, false);
+
+    if(dhcpConfigInfo[interfaceName] == "DualStack")
+    {
+        channelIPFamily = IPFamilyEnables::DualStack;
+    }
+    else if(dhcpConfigInfo[interfaceName] == "IPv4Only")
+    {
+        channelIPFamily = IPFamilyEnables::IPv4Only;
+    }
+    else if(dhcpConfigInfo[interfaceName] == "IPv6Only")
+    {
+        channelIPFamily = IPFamilyEnables::IPv6Only;
+    }
+
+    return channelIPFamily;
+}
+
 /** @brief Sets the DHCP v4 state on the given interface
  *
  *  @param[in] bus           - The bus object used for lookups
@@ -325,7 +418,8 @@ void deleteObjectIfExists(sdbusplus::bus::bus& bus, const std::string& service,
             strcmp(e.name(), "org.freedesktop.DBus.Error.UnknownObject") != 0)
         {
             // We want to rethrow real errors
-            throw;
+            log<level::ERR>("org.freedesktop.DBus.Error.UnknownObject",
+                            entry("ERROR=%s", e.what()));
         }
     }
 }
@@ -935,20 +1029,29 @@ RspType<> setLan(Context::ptr ctx, uint4_t channelBits, uint4_t reserved1,
             switch (static_cast<IPSrc>(static_cast<uint8_t>(flag)))
             {
                 case IPSrc::DHCP:
+                case IPSrc::Unspecified:
                 {
                     // The IPSrc IPMI command is only for IPv4
                     // management. Modifying IPv6 state is done using
                     // a completely different Set LAN Configuration
                     // subcommand.
-                    channelCall<setDHCPv4Property>(
-                        channel, EthernetInterface::DHCPConf::v4);
+                    switch (static_cast<IPFamilyEnables>(getChannelDhcpConfig(channel)))
+                    {
+                        case IPFamilyEnables::DualStack:
+                            channelCall<setDHCPProperty>(channel,EthernetInterface::DHCPConf::both);
+                            break;
+                        case IPFamilyEnables::IPv4Only:
+                            channelCall<setDHCPProperty>(channel,EthernetInterface::DHCPConf::v4);
+                            break;
+                        case IPFamilyEnables::IPv6Only:
+                            channelCall<setDHCPProperty>(channel,EthernetInterface::DHCPConf::v6);
+                            break;
+                    }
                     return responseSuccess();
                 }
-                case IPSrc::Unspecified:
                 case IPSrc::Static:
                 {
-                    channelCall<setDHCPv4Property>(
-                        channel, EthernetInterface::DHCPConf::none);
+                    channelCall<setDHCPProperty>(channel,EthernetInterface::DHCPConf::none);
                     return responseSuccess();
                 }
                 case IPSrc::BIOS:
@@ -1059,6 +1162,10 @@ RspType<> setLan(Context::ptr ctx, uint4_t channelBits, uint4_t reserved1,
             channelCall<reconfigureVLAN>(channel, vlan);
             return responseSuccess();
         }
+        case LanParam::ARPControl:
+        {
+            return responseInvalidFieldRequest();
+        }
         case LanParam::CiphersuiteSupport:
         case LanParam::CiphersuiteEntries:
         case LanParam::IPFamilySupport:
@@ -1073,11 +1180,18 @@ RspType<> setLan(Context::ptr ctx, uint4_t channelBits, uint4_t reserved1,
             {
                 return responseReqDataLenInvalid();
             }
+
+
+            EthernetInterface::DHCPConf dhcp =
+                    channelCall<getDHCPProperty>(channel);
+
             switch (static_cast<IPFamilyEnables>(enables))
             {
                 case IPFamilyEnables::DualStack:
-                    return responseSuccess();
                 case IPFamilyEnables::IPv4Only:
+                    saveChannelDhcpConfig(channel,enables);
+                    channelCall<setDHCPProperty>(channel,dhcp);
+                    return responseSuccess();
                 case IPFamilyEnables::IPv6Only:
                     return response(ccParamNotSupported);
             }
@@ -1385,6 +1499,12 @@ RspType<message::Payload> getLan(Context::ptr ctx, uint4_t channelBits,
             ret.pack(vlan);
             return responseSuccess(std::move(ret));
         }
+        case LanParam::ARPControl:
+        {
+            uint8_t arpCtrl = 0x2;
+            ret.pack(arpCtrl);
+            return responseSuccess(std::move(ret));
+        }
         case LanParam::CiphersuiteSupport:
         {
             if (getChannelSessionSupport(channel) ==
@@ -1424,7 +1544,7 @@ RspType<message::Payload> getLan(Context::ptr ctx, uint4_t channelBits,
         }
         case LanParam::IPFamilyEnables:
         {
-            ret.pack(static_cast<uint8_t>(IPFamilyEnables::DualStack));
+            ret.pack(static_cast<uint8_t>(getChannelDhcpConfig(channel)));
             return responseSuccess(std::move(ret));
         }
         case LanParam::IPv6Status:
diff --git a/transporthandler.hpp b/transporthandler.hpp
old mode 100644
new mode 100755
index b62de83..b5532d0
--- a/transporthandler.hpp
+++ b/transporthandler.hpp
@@ -65,6 +65,7 @@ enum class LanParam : uint8_t
     IPSrc = 4,
     MAC = 5,
     SubnetMask = 6,
+    ARPControl = 10,
     Gateway1 = 12,
     Gateway1MAC = 13,
     VLANId = 20,
-- 
2.7.4

