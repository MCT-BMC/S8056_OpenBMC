From bee97f9d4c869ca9911ff6bdda44ef501696e8da Mon Sep 17 00:00:00 2001
From: Osmond Chen <osmond.chen@mic.com.tw>
Date: Thu, 17 Mar 2022 10:47:14 +0800
Subject: [PATCH] Support Fru-related feature

Support baseboard fru reading(Removed)
Add FRU device read only property
Bypass FRU checking when writing FRU with invailed or null
Add PDB FRU device supportrd(Removed)
Support DCSCM Fru bus and address(Removed)
Support FRU reading via FRU json configuration file.
Remove black list feature and scan fru device via FRU json configuration file.
Add retry mechanism on Fru config checking.
Removed avoiding same eeprom feature.
Fix incorrect operator for findFruDevice function.

%% original patch: 0001-Support-Fru-related-feature.patch
---
 src/FruDevice.cpp | 253 ++++++++++++++++++++++++++++++++++++++++------
 src/FruUtils.cpp  |   4 +
 2 files changed, 228 insertions(+), 29 deletions(-)
 mode change 100644 => 100755 src/FruDevice.cpp
 mode change 100644 => 100755 src/FruUtils.cpp

diff --git a/src/FruDevice.cpp b/src/FruDevice.cpp
old mode 100644
new mode 100755
index dc7b77f..76771f1
--- a/src/FruDevice.cpp
+++ b/src/FruDevice.cpp
@@ -62,21 +62,46 @@ static constexpr bool debug = false;
 constexpr size_t maxFruSize = 512;
 constexpr size_t maxEepromPageIndex = 255;
 constexpr size_t busTimeoutSeconds = 5;
+static uint32_t FRU_OFFSET = 0x0000;
 
 constexpr const char* blacklistPath = PACKAGE_DIR "blacklist.json";
 
+// FRU configuration JSON
+constexpr const char* fruConfig =
+    "/usr/share/entity-manager/configurations/fru.json";
+
 const static constexpr char* baseboardFruLocation =
     "/etc/fru/baseboard.fru.bin";
 
 const static constexpr char* i2CDevLocation = "/dev";
 
+struct DeviceInfo
+{
+    uint32_t deviceID;
+    size_t size;
+    bool readOnly;
+};
+
+struct FruDeviceInfo
+{
+    uint32_t index;
+    size_t size;
+    bool readOnly;
+    int bus;
+    int address;
+    int offset;
+};
+
 using DeviceMap = boost::container::flat_map<int, std::vector<uint8_t>>;
+using DeviceInfoMap = std::unordered_map<std::string, struct DeviceInfo>;
 using BusMap = boost::container::flat_map<int, std::shared_ptr<DeviceMap>>;
 
 static std::set<size_t> busBlacklist;
 struct FindDevicesWithCallback;
 
 static BusMap busMap;
+static DeviceInfoMap deviceInfoMap;
+static std::vector<FruDeviceInfo> fruDeviceMap;
 
 static boost::container::flat_map<
     std::pair<size_t, size_t>, std::shared_ptr<sdbusplus::asio::dbus_interface>>
@@ -98,6 +123,27 @@ bool updateFRUProperty(
     sdbusplus::asio::object_server& objServer,
     std::shared_ptr<sdbusplus::asio::connection>& systemBus);
 
+static FruDeviceInfo* findFruDevice(std::vector<FruDeviceInfo> fruDeviceMap,
+                                    int bus, int address)
+{
+    for (auto it = fruDeviceMap.begin(); it != fruDeviceMap.end(); it++) {
+        if (it->bus == bus && it->address == address) {
+            return &(*it);
+        }
+    }
+    return NULL;
+}
+
+bool isFruDevice(std::vector<FruDeviceInfo> fruDeviceMap, int bus, int address)
+{
+    for (auto it = fruDeviceMap.begin(); it != fruDeviceMap.end(); it++) {
+        if (it->bus == bus && it->address == address) {
+            return true;
+        }
+    }
+    return false;
+}
+
 // Given a bus/address, produce the path in sysfs for an eeprom.
 static std::string getEepromPath(size_t bus, size_t address)
 {
@@ -125,7 +171,7 @@ static int64_t readFromEeprom(int flag __attribute__((unused)), int fd,
                               uint16_t address __attribute__((unused)),
                               uint16_t offset, uint8_t len, uint8_t* buf)
 {
-    auto result = lseek(fd, offset, SEEK_SET);
+    auto result = lseek(fd, offset + FRU_OFFSET, SEEK_SET);
     if (result < 0)
     {
         std::cerr << "failed to seek\n";
@@ -282,6 +328,14 @@ static std::vector<uint8_t> processEeprom(int bus, int address)
 
     std::string errorMessage = "eeprom at " + std::to_string(bus) +
                                " address " + std::to_string(address);
+
+    FruDeviceInfo* fruDevice = findFruDevice(fruDeviceMap,bus,address);
+
+    if(fruDevice != NULL)
+    {
+        FRU_OFFSET = fruDevice->offset;
+    }
+
     std::vector<uint8_t> device = readFRUContents(
         0, file, static_cast<uint16_t>(address), readFromEeprom, errorMessage);
 
@@ -342,7 +396,7 @@ std::set<int> findI2CEeproms(int i2cBus,
         foundList.insert(address);
 
         std::vector<uint8_t> device = processEeprom(i2cBus, address);
-        if (!device.empty())
+        if (!device.empty() || isFruDevice(fruDeviceMap, i2cBus, address))
         {
             devices->emplace(address, device);
         }
@@ -530,6 +584,133 @@ void loadBlacklist(const char* path)
     return;
 }
 
+static int CheckFruConfig(void)
+{
+    std::ifstream motherboardConf(fruConfig);
+    if (motherboardConf.is_open() == false)
+    {
+        std::cerr << "Failed to open file: " << fruConfig << "\n";
+        return -1;
+    }
+
+    return 0;
+}
+
+
+static void getFruDevices(void)
+{
+    int ret;
+
+    // Find fru device from motherboard config json.
+    while (1)
+    {
+        ret = CheckFruConfig();
+        if (ret >= 0)
+        {
+            break;
+        }
+        else
+        {
+            sleep(3);
+        }
+    }
+
+    std::ifstream motherboardConf(fruConfig);
+    auto data = nlohmann::json::parse(motherboardConf, nullptr, false);
+    if (data.is_discarded())
+    {
+        std::cerr << "Invalid json format: " << fruConfig << "\n";
+        return ;
+    }
+    auto fruFind = data.find("Fru");
+    if (fruFind != data.end())
+    {
+        for (auto& fru : *fruFind)
+        {
+            uint32_t index;
+            size_t size;
+            bool readOnly = false;
+            int bus;
+            std::string address;
+            std::string offset;
+
+            auto indexFind = fru.find("Index");
+            if (indexFind != fru.end())
+            {
+                indexFind->get_to(index);
+            }
+            else
+            {
+                std::cerr << "Can't find Index in fru json\n";
+                continue;
+            }
+
+            auto sizeFind = fru.find("Size");
+            if (sizeFind != fru.end())
+            {
+                sizeFind->get_to(size);
+            }
+            else
+            {
+                std::cerr << "Can't find Size in fru json\n";
+                continue;
+            }
+
+            auto busFind = fru.find("Bus");
+            if (busFind != fru.end())
+            {
+                busFind->get_to(bus);
+            }
+            else
+            {
+                std::cerr << "Can't find Bus in fru json\n";
+                continue;
+            }
+
+            auto addressFind = fru.find("Address");
+            if (addressFind != fru.end())
+            {
+                addressFind->get_to(address);
+            }
+            else
+            {
+                std::cerr << "Can't find Address in fru json\n";
+                continue;
+            }
+
+            auto offsetFind = fru.find("FRU_OFFSET");
+            if (offsetFind != fru.end())
+            {
+                offsetFind->get_to(offset);
+            }
+            else
+            {
+                std::cerr << "Can't find FRU offset in fru json\n";
+                continue;
+            }
+
+            auto readOnlyFind = fru.find("ReadOnly");
+            if (readOnlyFind != fru.end())
+            {
+                readOnlyFind->get_to(readOnly);
+            }
+
+            const int hexBase = 16;
+            int addressInt = std::stoi(address, nullptr, hexBase);
+            int offsetInt = std::stoi(offset, nullptr, hexBase);
+
+            struct DeviceInfo deviceInfo = {index, size, readOnly};
+            struct FruDeviceInfo fruDeviceInfo = {index, size, readOnly, bus, addressInt, offsetInt};
+
+            std::stringstream deviceBusAddr;
+            deviceBusAddr << bus << "-" << std::right << std::setfill('0')
+                          << std::setw(4) << std::hex << addressInt;
+            deviceInfoMap.emplace(deviceBusAddr.str(), deviceInfo);
+            fruDeviceMap.insert(fruDeviceMap.end(), fruDeviceInfo);
+        }
+    }
+}
+
 static void findI2CDevices(const std::vector<fs::path>& i2cBuses,
                            BusMap& busmap, bool powerIsOn,
                            sdbusplus::asio::object_server& objServer)
@@ -543,16 +724,6 @@ static void findI2CDevices(const std::vector<fs::path>& i2cBuses,
             std::cerr << "Cannot translate " << i2cBus << " to int\n";
             continue;
         }
-        if (busBlacklist.find(bus) != busBlacklist.end())
-        {
-            continue; // skip previously failed busses
-        }
-
-        int rootBus = getRootBus(bus);
-        if (busBlacklist.find(rootBus) != busBlacklist.end())
-        {
-            continue;
-        }
 
         auto file = open(i2cBus.c_str(), O_RDWR);
         if (file < 0)
@@ -590,7 +761,11 @@ static void findI2CDevices(const std::vector<fs::path>& i2cBuses,
         }
 
         // fd is closed in this function in case the bus locks up
-        getBusFRUs(file, 0x03, 0x77, bus, device, powerIsOn, objServer);
+        for (auto it = fruDeviceMap.begin(); it != fruDeviceMap.end(); it++) {
+            if (it->bus == bus) {
+                getBusFRUs(file, it->address, it->address, bus, device, powerIsOn, objServer);
+            }
+        }
 
         if (debug)
         {
@@ -617,6 +792,7 @@ struct FindDevicesWithCallback :
     }
     void run()
     {
+        getFruDevices();
         findI2CDevices(_i2cBuses, _busMap, _powerIsOn, _objServer);
     }
 
@@ -657,9 +833,12 @@ void addFruObjectToDbus(
     resCodes res = formatIPMIFRU(device, formattedFRU);
     if (res == resCodes::resErr)
     {
-        std::cerr << "failed to parse FRU for device at bus " << bus
-                  << " address " << address << "\n";
-        return;
+        if(!isFruDevice(fruDeviceMap, bus, address))
+        {
+            std::cerr << "failed to parse FRU for device at bus " << bus
+                    << " address " << address << "\n";
+            return;
+        }
     }
     if (res == resCodes::resWarn)
     {
@@ -701,17 +880,6 @@ void addFruObjectToDbus(
             std::string path = busIface.second->get_object_path();
             if (std::regex_match(path, std::regex(productName + "(_\\d+|)$")))
             {
-                if (isMuxBus(bus) && address == busIface.first.second &&
-                    (getFRUInfo(static_cast<uint8_t>(busIface.first.first),
-                                static_cast<uint8_t>(busIface.first.second)) ==
-                     getFRUInfo(static_cast<uint8_t>(bus),
-                                static_cast<uint8_t>(address))))
-                {
-                    // This device is already added to the lower numbered bus,
-                    // do not replicate it.
-                    return;
-                }
-
                 // Check if the match named has extra information.
                 found = true;
                 std::smatch baseMatch;
@@ -798,6 +966,14 @@ void addFruObjectToDbus(
     iface->register_property("BUS", bus);
     iface->register_property("ADDRESS", address);
 
+    std::stringstream deviceBusAddr;
+    deviceBusAddr << bus << "-" << std::right << std::setfill('0')
+                  << std::setw(4) << std::hex << address;
+    auto deviceInfo = deviceInfoMap[deviceBusAddr.str()];
+    iface->register_property("INDEX", deviceInfo.deviceID);
+    iface->register_property("SIZE", deviceInfo.size);
+    iface->register_property("READONLY", deviceInfo.readOnly);
+
     iface->initialize();
 }
 
@@ -832,8 +1008,11 @@ bool writeFRU(uint8_t bus, uint8_t address, const std::vector<uint8_t>& fru)
     // verify legal fru by running it through fru parsing logic
     if (formatIPMIFRU(fru, tmp) != resCodes::resOK)
     {
-        std::cerr << "Invalid fru format during writeFRU\n";
-        return false;
+        if(!isFruDevice(fruDeviceMap, bus, address))
+        {
+            std::cerr << "Invalid fru format during writeFRU\n";
+            return false;
+        }
     }
     // baseboard fru
     if (bus == 0 && address == 0)
@@ -860,6 +1039,22 @@ bool writeFRU(uint8_t bus, uint8_t address, const std::vector<uint8_t>& fru)
             return false;
         }
 
+        FruDeviceInfo* fruDevice = findFruDevice(fruDeviceMap,bus,address);
+
+        if(fruDevice != NULL)
+        {
+            FRU_OFFSET = fruDevice->offset;
+        }
+
+        //mitac support fru offset for write operation
+        auto result = lseek(eeprom, FRU_OFFSET, SEEK_SET);
+        if (result < 0)
+        {
+            std::cerr << "failed to seek\n";
+            return false;
+        }
+        //mitac end
+
         ssize_t writtenBytes = write(eeprom, fru.data(), fru.size());
         if (writtenBytes < 0)
         {
diff --git a/src/FruUtils.cpp b/src/FruUtils.cpp
old mode 100644
new mode 100755
index 1152f87..767190c
--- a/src/FruUtils.cpp
+++ b/src/FruUtils.cpp
@@ -444,6 +444,7 @@ resCodes
                 }
             }
         } while (state == DecodeState::ok);
+#if 0
         for (; fruBytesIter < fruBytesIterEndArea; fruBytesIter++)
         {
             uint8_t c = *fruBytesIter;
@@ -455,6 +456,7 @@ resCodes
                 break;
             }
         }
+#endif
     }
 
     return ret;
@@ -551,6 +553,7 @@ bool validateHeader(const std::array<uint8_t, I2C_SMBUS_BLOCK_MAX>& blockData)
         return false;
     }
 
+#if 0 //MiTAC : ipmitool issue: fru edit don't check the non-existing area and fill incorrect area offset.
     // verify offsets are 0, or don't point to another offset
     std::set<uint8_t> foundOffsets;
     for (int ii = 1; ii < 6; ii++)
@@ -565,6 +568,7 @@ bool validateHeader(const std::array<uint8_t, I2C_SMBUS_BLOCK_MAX>& blockData)
             return false;
         }
     }
+#endif
 
     // validate checksum
     size_t sum = 0;
-- 
2.25.1

